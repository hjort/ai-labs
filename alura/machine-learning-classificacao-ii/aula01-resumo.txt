Repara que além de dados com duas categorias, podemos também conter dados com mais de duas categorias, como por exemplo, a situação do cliente em relação ao nosso site, isto é, se ele está alegre, neutro ou chateado. Levando em consideração apenas esse exemplo, vimos que os algoritmos que utilizamos anteriormente (AdaBoost e Multinomial) não conseguiam classificar esses dados de forma eficiente, em outras palavras, obtinham o mesmo resultado que o algoritmo base, portanto, não poderíamos utilizá-los no mundo real. Porém, além do AdaBoost e Multinomial, que são algoritmos bons para dados com duas categorias, temos também os algoritmos OneVsRest e o OneVsOne que servem justamente para classificar elementos que podem ter mais de duas categorias. Além da eficiência dos algoritmos OneVsRest e OneVsOne, vimos que ambos possuem uma certa diferença quanto à performance, pois o OneVsRest cresce constantemente de acordo com a quantidade de elementos dado um conjunto de dados, ou seja, se tivermos 3 elementos, serão 3 testes, 4 elementos 4 testes. Mas, no OneVsOne, a abordagem é bem diferente, pois ele é um algoritmo quadrático, ou seja, ele cresce muito de acordo com a quantidade de elementos, em outras palavras, quantos mais elementos tivermos, serão realizados muito mais testes.

Vimos também a importância de rodar diversos algoritmos para o mesmo conjunto de dados, porém, precisamos sempre ficar atentos para não viciar o nosso algoritmo, ou seja, não podemos rodar um algoritmo, obter um resultado e então, de acordo com o resultado rodar um outro algoritmo. O ideal é que sempre rodemos todos os algoritmos de uma vez, pois dessa forma elegemos o algoritmo vencedor e rodamos para um conjunto de dados desconhecidos.

Nesta aula, aprendemos:
- Como classificar um elemento em 3 categorias
- Os algoritmos One vs Rest e One vs One
- A comparação entre os algoritmos OneVsRest, OneVsOne, MultinomialNB e AdaBoostClassifier

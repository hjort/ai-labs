# -*- coding: utf-8 -*-
"""DLparte2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QWYYTD9L_SjFbvn9tNfUAav3tS767P4z
"""

import numpy as np
import matplotlib.pyplot as plt

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 1.x
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import load_model
print(tf.__version__)

dataset = keras.datasets.fashion_mnist
((imagens_treino, identificacoes_treino), (imagens_teste, identificacoes_teste)) = dataset.load_data()

len(imagens_treino)
imagens_treino.shape
imagens_teste.shape
len(identificacoes_teste)
identificacoes_treino.min()
identificacoes_treino.max()

total_de_classificacoes = 10
nomes_de_classificacoes = ['Camiseta', 'Calça', 'Pullover', 
                           'Vestido', 'Casaco', 'Sandália', 'Camisa',
                           'Tênis', 'Bolsa', 'Bota']

plt.imshow(imagens_treino[0])
plt.colorbar()

imagens_treino = imagens_treino/float(255)

# https://keras.io/layers/core/
modelo = keras.Sequential([
    keras.layers.Flatten(input_shape=(28, 28)),
    keras.layers.Dense(256, activation=tensorflow.nn.relu),
    keras.layers.Dropout(0.2),
    keras.layers.Dense(10, activation=tensorflow.nn.softmax)
])

# https://keras.io/optimizers/
adam = keras.optimizers.Adam(lr=0.002) # lr: Learning Rate

# https://keras.io/callbacks/
parando_cedo = [keras.callbacks.EarlyStopping(monitor='val_loss'),
                keras.callbacks.ModelCheckpoint(filepath='melhor_modelo.hdf5',
                                                monitor='val_loss',
                                                save_best_only=True)]

# https://keras.io/models/sequential/#compile
modelo.compile(optimizer=adam,
               loss='sparse_categorical_crossentropy',
               metrics=['accuracy'])

# https://keras.io/models/sequential/#fit
historico = modelo.fit(imagens_treino, identificacoes_treino, 
                       batch_size=960, #480
                       epochs=5, #5
                       validation_split=0.2, #0.2
                       callbacks=parando_cedo)

modelo = keras.Sequential([ 
    keras.layers.Flatten(input_shape=(28, 28)),
    keras.layers.Dense(256, activation=tensorflow.nn.relu),
    keras.layers.Dropout(0.2),
    keras.layers.Dense(10, activation=tensorflow.nn.softmax)
])

modelo.compile(optimizer='adam', 
               loss='sparse_categorical_crossentropy',
               metrics=['accuracy'])

historico = modelo.fit(imagens_treino, identificacoes_treino, epochs=5, validation_split=0.2)

sumario_do_modelo = modelo.summary()

pesos_camada_dense = modelo.layers[1].get_weights()
pesos_camada_dense

modelo.save('modelo.h5')
modelo_salvo = load_model('modelo.h5')

plt.plot(historico.history['acc'])
plt.plot(historico.history['val_acc'])
plt.title('Acurácia por épocas')
plt.xlabel('épocas')
plt.ylabel('acurácia')
plt.legend(['treino', 'validação'])

plt.plot(historico.history['loss'])
plt.plot(historico.history['val_loss'])
plt.title('Perda por épocas')
plt.xlabel('épocas')
plt.ylabel('perda')
plt.legend(['treino', 'validação'])

testes = modelo.predict(imagens_teste)
print('resultado teste:', np.argmax(testes[1]))
print('número da imagem de teste:', identificacoes_teste[1])

testes_modelo_salvo = modelo_salvo.predict(imagens_teste)
print('resultado teste modelo salvo:', np.argmax(testes_modelo_salvo[1]))
print('número da imagem de teste:', identificacoes_teste[1])

perda_teste, acuracia_teste = modelo.evaluate(imagens_teste, identificacoes_teste)
print('Perda do teste:', perda_teste)
print('Acurácia do teste:', acuracia_teste)

modelo.get_config()

plt.plot(historico.history['loss'])
plt.plot(historico.history['val_loss'])
plt.title('Perda por épocas')
plt.xlabel('épocas')
plt.ylabel('perda')
plt.legend(['treino', 'validação'])

pesos_camada_dense = modelo.layers[1].get_weights()[0]
pesos_camada_dense

pesos_camada_dense.shape

pesos_camada_dense_zerados = np.zeros((784, 256))

pesos_camada_dense_aleatorios = np.random.rand(784, 256)

# os vieses são o segundo resultado no array devolvido pela função de pesos
vieses_camada_dense = modelo.layers[1].get_weights()[1]
vieses_camada_dense.shape

vieses_camada_dense_zerados = np.zeros((256,))

# inicializar os pesos com valores aleatórios e vieses com 0
modelo.layers[1].set_weights(
    [pesos_camada_dense_aleatorios, vieses_camada_dense_zerados]
)

modelo.layers[1].get_weights()

modelo.layers[1].set_weights(
    [pesos_camada_dense_zerados, vieses_camada_dense_zerados]
)

